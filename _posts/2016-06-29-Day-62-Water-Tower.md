---
layout: defaultpost
title: "Water Tower"
date: 2016-06-29
---

In my mock interview yesterday, one of the technical questions was water tower. Given a data structure with n number of columns and n number of rows made up of either a block or an empty space, create a program that finds out the how many blocks of water the data structure can hold. First I had to determine how many blocks of water this particular data structure could hold, with the input being an infinite amount of water pouring over the water tower equally until each block is full and water overflows through the sides. In this case the number was 11.<br />
On to the programming, I used 0 as an empty space and 1 as a block. I also narrowed down the data structure to be an array, with inner arrays that each represent a row, and the elements inside the inner arrays is either a 0 for empty space or 1 for a block. An empty space can only hold water if there is a 1 to the left of it and a 1 to the right of it. Or else water would spill over the side if it wasn't enclosed by blocks. I create a variable hasLeft initially set to false. This will be true for the first 1 found, because it will be on the left side of the 0's that can hold water. I iterate over each inner array and check each element. If a 1 is found, hasLeft is set to true, and now every 0 after can potentially hold water. To keep track of this, I set a temporary variable called potential that is incremented for each 0 found if hasLeft is true. If another 1 is found when hasLeft is true, then the potential 0's can hold water, because they are enclosed between blocks. Potential is then added to the total and reset to 0 because 0's after this must also have a 1 on their right, which is uncertain for now. The process is repeated to check for another 1, and potential is incremented for 0's after another 1 is found, until we reached the end of the array.<br />
After reaching the end of the inner array, we move on to the next inner array which would be another row in the water tower until we have checked each row. The time complexity ranges from O(m x n), with m and n being the number of rows and columns, to O(n^2) if m is greater than or equal to n. Overall I enjoyed solving the problem, and there is an even more optimized solution in which there is only one array and each element is the height of the column, and that time complexity is linear.